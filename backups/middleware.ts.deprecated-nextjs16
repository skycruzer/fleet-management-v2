/**
 * Next.js Middleware - Route Protection & Rate Limiting
 * Author: Maurice Rondeau (Sprint 1.2 - Nov 2025)
 * Version: 1.0.0
 *
 * Provides centralized route protection, authentication, and rate limiting
 * for both admin dashboard (/dashboard/*) and pilot portal (/portal/*) routes.
 *
 * Features:
 * - Dual authentication system support (Supabase Auth + Custom Pilot Auth)
 * - Route-specific protection patterns
 * - Rate limiting integration
 * - Session refresh and cookie management
 */

import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'
import { cookies } from 'next/headers'

/**
 * Route Configuration
 */
const PUBLIC_ROUTES = [
  '/',
  '/auth/login',
  '/auth/signup',
  '/auth/forgot-password',
  '/auth/reset-password',
  '/portal/login',
  '/portal/register',
  '/api/auth',
  '/api/portal/auth',
]

const ADMIN_ROUTES = ['/dashboard/admin']
const MANAGER_ROUTES = ['/dashboard/leave', '/dashboard/certifications']
const DASHBOARD_ROUTES = ['/dashboard']
const PORTAL_ROUTES = ['/portal']

/**
 * Check if route matches pattern
 */
function matchesRoute(pathname: string, routes: string[]): boolean {
  return routes.some((route) => pathname.startsWith(route))
}

/**
 * Check if route is public
 */
function isPublicRoute(pathname: string): boolean {
  return PUBLIC_ROUTES.some(
    (route) => pathname === route || pathname.startsWith(route)
  )
}

/**
 * Verify pilot session from custom authentication
 */
async function verifyPilotSession(request: NextRequest): Promise<boolean> {
  try {
    const cookieStore = await cookies()
    const pilotSessionCookie = cookieStore.get('pilot_session_token')

    if (!pilotSessionCookie?.value) {
      return false
    }

    const sessionData = JSON.parse(pilotSessionCookie.value)
    const expiresAt = new Date(sessionData.expires_at)

    // Check if session is still valid
    if (expiresAt <= new Date()) {
      return false
    }

    return true
  } catch (error) {
    console.error('Error verifying pilot session:', error)
    return false
  }
}

/**
 * Main Middleware Function
 */
export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl

  // Allow public routes
  if (isPublicRoute(pathname)) {
    return NextResponse.next()
  }

  // Create Supabase client for middleware
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: any) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: any) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  // ========================================================================
  // PILOT PORTAL ROUTES (/portal/*)
  // ========================================================================
  if (matchesRoute(pathname, PORTAL_ROUTES)) {
    // Check for pilot session (custom auth)
    const hasPilotSession = await verifyPilotSession(request)

    if (!hasPilotSession) {
      // No pilot session - redirect to pilot login
      const url = request.nextUrl.clone()
      url.pathname = '/portal/login'
      url.searchParams.set('redirect', pathname)
      return NextResponse.redirect(url)
    }

    // Pilot session valid - allow access
    return response
  }

  // ========================================================================
  // ADMIN DASHBOARD ROUTES (/dashboard/*)
  // ========================================================================
  if (matchesRoute(pathname, DASHBOARD_ROUTES)) {
    // Check Supabase Auth session
    const {
      data: { user },
      error,
    } = await supabase.auth.getUser()

    if (error || !user) {
      // No valid session - redirect to login
      const url = request.nextUrl.clone()
      url.pathname = '/auth/login'
      url.searchParams.set('redirect', pathname)
      return NextResponse.redirect(url)
    }

    // Admin-only routes
    if (matchesRoute(pathname, ADMIN_ROUTES)) {
      // Check if user is admin
      const { data: adminUser } = await supabase
        .from('an_users')
        .select('role')
        .eq('id', user.id)
        .single()

      if (adminUser?.role !== 'admin') {
        // Not an admin - redirect to dashboard home
        const url = request.nextUrl.clone()
        url.pathname = '/dashboard'
        return NextResponse.redirect(url)
      }
    }

    // Manager-only routes
    if (matchesRoute(pathname, MANAGER_ROUTES)) {
      // Check if user is admin or manager
      const { data: adminUser } = await supabase
        .from('an_users')
        .select('role')
        .eq('id', user.id)
        .single()

      if (
        adminUser?.role !== 'admin' &&
        adminUser?.role !== 'manager'
      ) {
        // Not admin or manager - redirect to dashboard home
        const url = request.nextUrl.clone()
        url.pathname = '/dashboard'
        return NextResponse.redirect(url)
      }
    }

    // Valid admin session - allow access
    return response
  }

  // Default: allow all other routes
  return response
}

/**
 * Middleware Configuration
 * Specify which routes should run through middleware
 */
export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder files
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
